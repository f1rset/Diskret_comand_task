# Diskret_comand_task(Звіт)

1. Функція read_directed_graph є для зчитування орієнтованого графу з файлу csv. Функція повертає словник, де ключі - це вершини, а значення - це список зв'язаних з ними вершин.  
file_path: Аргумент, що представляє шлях до файлу, що містить орієнтований граф. Повертає словник, що представляє орієнтований граф.
Cловник graph буде зберігати орієнтований граф. 
Функція читає кожен рядок з файлу, видаляє будь-які пробіли з початку або кінця та розбиває його на дві вершини, розділяючи комою. 
Якщо початкова вершина вже є в графі, додається кінцева вершина до списку зв'язаних з нею вершин. 
Якщо початкова вершина відсутня в графі, додається початкова вершина до графа з кінцевою вершиною як першим елементом його списку. 
Якщо кінцева вершина відсутня в графі, то вона додається до графа з порожнім списком. 
Сортує ключі графа в порядку зростання. Створює новий словник (sorted_graph), де ключі відсортовані, а значення - відповідні вершині списки.

Функція read_undirected_graph є призначена для зчитування неорієнтованого графа з файлу та представлення його у вигляді словника. file_path: Рядок, що представляє шлях до файлу, що містить неорієнтований граф. Повертає словник, що представляє неорієнтований граф. Словник graph буде зберігати неорієнтований граф. Функція читає кожен рядок з файлу, видаляє будь-які пробіли з початку або кінця та розбиває його на дві вершини, розділяючи комою. 
Для неорієнтованого графа обидві вершини додаються до списку значень обох вершин. Сортує ключі графа в порядку зростання. 
Створює новий словник (sorted_graph), де ключі відсортовані, а значення - відповідні списки. Повертає відсортований словник, що представляє неорієнтований граф. 

2. Функція write_file_directed призначена для запису орієнтованого графа з словника у файл. graph: Словник, що представляє орієнтований граф.
file_name: Рядок, що представляє ім'я файлу, в який буде записаний граф. Проходиться по кожному ключу та значенню в словнику.
Додає пари [key, elem] до списку write_list, де key - це початкова вершина, а elem - кінцева.
Відкриває файл для запису. Проходиться по кожній парі у списку write_list. Записує пару у файл у форматі ‘pair[0],pair[-1]\n’. Якщо це остання пара у списку, то записується без символу нового рядка.

Функція write_file_undirected призначена для запису неорієнтованого графа зі словника у файл.  
graph: Словник, що представляє неорієнтований граф. 
file_name: Рядок, що представляє ім'я файлу, в який буде записаний граф. 
Проходиться по кожному ключу та значенню в словнику. 
Додає пару [key, elem] до списку write_list, якщо ця пара ще не знаходиться у списку. Наявність пари [elem, key] також перевіряється, щоб уникнути повторення ребра для неорієнтованого графа.  
Відкриває файл для запису. Проходиться по кожній парі у списку write_list. Записує пару у файл у форматі ‘pair[0],pair[-1]\n’. Якщо це остання пара у списку, то записується без символу нового рядка.

3. Функція find_components знаходить компоненти зв'язності в неорієнтованому графі.
Алгоритм працює так:
  1) Створює два порожніх списки: visited для відвіданих вершин і components для компонентів зв'язності.
  2) Перебирає всі вершини графа.
  3) Якщо вершина не була відвідана раніше (start not in visited):
  4) Викликає функцію dfs для цієї вершини як стартової.
  5) Результат dfs (список відвіданих вершин) додає до списку components (з мінімальним елементом на початку).
  6) Додає всі вершини з результату dfs до списку visited.
  7) Повертає список компонентів зв'язності, представлений мінімальними елементами з кожного компонента.
Тобто, функція шукає всі шляхи з кожної невідвіданої вершини та додає їх до окремого компонента зв'язності.

4. Функція strong_coherence_oriented отримує на вхід граф у вигляді словника та шукає компоненти сильної зв’язності за допомогою алгоритму Косараджу.
Містить в собі три підфункції, а саме: dfs та dfs_scc (створює порядок в stack), transpose (перетворює граф).
![image](https://github.com/f1rset/Diskret_comand_task/assets/149361945/bc1de612-be76-4fe5-a2bc-f4c7f9a2511e)
Алгоритм працює наступним чином:
  1) Кожній вершині надається значення visited = False
  2) Проходиться dfs по графу доти поки кожна вершина не буде мати значення True, вершини додаються в stack
  3) Перетворюється граф за допомогою функції transpose(напрямки ребер міняються в протилежну сторону)
  4) Знову кожній вершині (тепер з transposed_graph) надається значення visited = False
  5) Виконується цикл (поки в stack є елементи), який проходиться dfs_scc по новому графу і додає пройдені вершини в component, який вкінці циклу архівується в dict і додається в результат.

5. Функція find_con_points, отримавши на вхід словник і створивши його копію, проходиться по його вершинах, видаляє одну з них. Потім проходиться по всіх ребрах і видаляє всі, що були інцидентними до вершини яку ми видалили. Виконавши все це, функція викликає dfs_mod, щоб перевірити чи досягнуто кінцевої вершини, якщо ні то додає вершину в список з'єднувальних.
   Функція dfs_mod виконує пошук шляху від початкової вершини до кінцевої, які є в графі після видалення однієї з вершин. Вона використовує підфунцію check_path, яка викликається рекурсивно. check_path проходиться по графу шляхом пошуку в глибину і повертає список вершин які були виявлені цим пошуком. dfs_mod повертає булеве значення: чи досягнуто кінцевої вершини, чи ні.

6. Функція search_for_bridges приймає словник з графом і повертає список з усіма мостами цього графу. Спочатку створюється два списки res і edges після цього в edges записуємо всі ребра графу без повторень. Потім знаходимо найменшу і найбільшу вершину графу. І робимо копію списку для редагування в майбутньому. Після цього проходимося по всім ребрам в списку edges, після чого видаляємо ребро зі списку edges_copy і передаємо його функції find_path, якщо вона повертає False то додаємо це ребро в результат.
Функція find_path перевіряє, чи існує шлях від заданої вершини до іншої у графі. Вона приймає кількість вершин n, список ребер edges, початкову вершину source та кінцеву вершину destination, створює граф, використовуючи словник, де ключі - це вершини, а значення - списки сусідніх вершин. Використовуємо рекурсивну функцію neighbor_search, яка шукає шлях з початкової вершини до кінцевої. Повертаємо значення True, якщо шлях існує, та False у протилежному випадку.
